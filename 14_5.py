# Задача 1. Урок информатики — 2
# Что нужно сделать
# В прошлый раз учитель написал программу, которая выводит числа в формате плавающей точки, однако он вспомнил,
# что не учёл одну важную штуку: числа-то могут идти от нуля.
#
# Задано положительное число x (x > 0). Ваша задача преобразовать его в формат плавающей точки, то есть x=a · 10^b,
# где 1≤a<10. Обратите внимание, что x теперь больше нуля, а не больше единицы. Обеспечьте контроль ввода.

def print_float_point(number):
    degree = 0
    while number >= 10 or number < 1:
        if number < 1:
            number *= 10
            degree -= 1
        elif number >= 10:
            number /= 10
            degree += 1
    print(f'Формат плавающей точки: x = {number} * 10 ** {degree}')

number = float(input('Введите число: '))
print_float_point(number)

# Задача 2. Функция максимума
# Что нужно сделать
# Юра пишет полезные функции для Python, чтобы остальным программистам стало проще работать. Он захотел написать
# функцию, которая будет находить максимум из перечисленных чисел. Функция для нахождения максимума из двух чисел
# у него уже есть. Юра задумался: может быть, её можно как-то использовать для нахождения максимума уже от трёх чисел?
#
# Помогите написать Юре программу, которая находит максимум из трёх чисел. Для этого используйте только функцию
# нахождения максимума из двух чисел.
import math

def max_number(a, b):
    return (a + b + math.fabs(a - b)) / 2

def max_three_number(a, b, c):
    first_max_number = max_number(a, b)
    print(max_number(first_max_number, c))

a = int(input('Введите первое число: '))
b = int(input('Введите второе число: '))
c = int(input('Введите третье число: '))
max_three_number(a, b, c)

# Задача 3. Число наоборот — 2
# Что нужно сделать
# Пользователь вводит два числа — N и K. Напишите программу, которая заменяет каждое число на число, которое
# получается из исходного записью его цифр в обратном порядке, затем складывает их, снова переворачивает и выводит
# ответ на экран.

def get_reverse_number(number):
    reverse_number = 0
    while number > 0:
        reverse_number = reverse_number * 10 + number % 10
        number //= 10
    return reverse_number

num1 = int(input('Введите первое число: '))
num2 = int(input('Введите второе число: '))
print(f'Первое число наоборот: {get_reverse_number(num1)}')
print(f'Второе число наоборот: {get_reverse_number(num2)}')
print(f'Сумма: {num1 + num2}')
print(f'Сумма наоборот: {get_reverse_number(num1) + get_reverse_number(num2)}')


# Задача 4. Урок информатики — 3
# Что нужно сделать
# Наконец-то учитель смог объяснить детям, что такое эта «плавающая точка». Однако долго его радость не продлилась,
# ведь на следующем уроке нужно будет объяснить такие страшные слова, как «экспоненциальное», «мантисса» и «порядок».
# Хоть старшеклассники и знакомы с экспонентой, учитель всё равно не уверен, что здесь всё будет понятно. Поэтому
# для наглядности он также написал программу.
#
# На вход подаётся строка — это экспоненциальная форма числа. Напишите программу, которая выводит отдельно мантиссу
# и отдельно порядок этого числа.

def explain_number(number):
    mantissa = ''
    explain = ''
    order_number = ''
    for letter in number:
        if letter == 'e':
            mantissa = explain
            explain = ''
        else:
            explain = explain + letter
    order_number = explain
    print(f'Мантиса: {mantissa}')
    print(f'Порядок числа: {order_number}')

number = input('Введите число в экспоненциальной форме: ')
explain_number(number)


# Задача 5. Недоделка — 2
# Что нужно сделать
# Вы всё так же работаете в конторе по разработке игр и смотрите программы прошлого горе-программиста. В одной из игр
# для детей, связанной с мультяшной работой с числами, вам нужно было написать код по следующим условиям: программа
# получает на вход два числа. В первом числе должно быть не меньше трёх цифр, во втором числе — не меньше четырёх,
# иначе программа выдаёт ошибку. Если всё нормально, то в каждом числе первая и последняя цифра меняются местами,
# а затем выводится их сумма.
#
# И тут вы натыкаетесь на программу, которая была написана прошлым программистом и которая как раз решает такую
# задачу! Однако старший программист сказал вам немного переписать этот код, чтобы он не выглядел так ужасно. Да
# и вам самим становится, мягко говоря, не по себе от него.
#
# Разбейте приведённую ниже программу на функции. Повторений кода должно быть как можно меньше. Сделайте так,
# чтобы в основной части программы был только ввод чисел, затем изменённые числа и вывод их суммы.


def chek_count_number(number, count):
    first_num_count = 0
    temp = number

    while temp > 0:
        first_num_count += 1
        temp = temp // 10
    if first_num_count < count:
        print(f"В числе меньше {count} цифр.")
        return False
    return True

def change_number(number, count):
    last_digit = number % 10
    first_digit = number // 10 ** (count - 1)
    between_digits = number % 10 ** (count - 1) // 10
    number = last_digit * 10 ** (count - 1) + between_digits * 10 + first_digit
    return number


first_n = int(input("Введите первое число: "))
second_n = int(input("Введите второе число: "))


if chek_count_number(first_n, 3) and chek_count_number(second_n, 4):
    change_first_n = change_number(first_n, 3)
    print(f'Изменённое первое число: {change_first_n}')
    change_second_n = change_number(second_n, 4)
    print(f'Изменённое первое число: {change_second_n}')
    print(f'\nСумма чисел: {change_first_n + change_first_n}')



# Задача 6. Маятник
# Что нужно сделать
# Известно, что амплитуда качающегося маятника с каждым разом затухает на 8,4% от амплитуды прошлого колебания.
# Если качнуть маятник, то, строго говоря, он не остановится никогда, просто амплитуда будет постоянно уменьшаться
# до тех пор, пока мы не сочтём такой маятник остановившимся. Напишите программу, определяющую, сколько раз
# качнётся маятник, прежде чем он, по нашему мнению, остановится.
#
# Программа получает на вход начальную амплитуду колебания в сантиметрах и конечную амплитуду его колебаний, которая
# считается остановкой маятника. Обеспечьте контроль ввода.
def get_count_fluctuation(first_amplitude, end_amplitude):
    count_fluctuation = 0
    while first_amplitude > end_amplitude:
        first_amplitude = first_amplitude - first_amplitude * 8.4 / 100
        count_fluctuation += 1
    return count_fluctuation


first_amplitude = float(input('Введите начальную амплитуду: '))
end_amplitude = float(input('Введите амплитуду остановки: '))
print(f'Маятник считается остановившимся через {get_count_fluctuation(first_amplitude, end_amplitude)} колебаний')

# Задача 7. Яйца
# Что нужно сделать
# В рамках программы колонизации Марса компания «Спейс Инжиниринг» вывела особую породу черепах, которые по задумке
# должны размножаться, откладывая яйца в марсианском грунте. Откладывать яйца слишком близко к поверхности опасно
# из-за радиации, а слишком глубоко — из-за давления грунта и недостатка кислорода. Вообще, факторов очень много,
# но специалисты проделали большую работу и предположили, что уровень опасности для черепашьих яиц рассчитывается
# по формуле D = x^3 − 3x^2 − 12x + 10, где x — глубина кладки в метрах, а D — уровень опасности в условных
# единицах. Для тестирования гипотезы нужно взять пробу грунта на безопасной, согласно формуле, глубине.
#
# Напишите программу, находящую такое значение глубины х, при котором уровень опасности как можно более близок к
# нулю. На вход программе подаётся максимально допустимое отклонение уровня опасности от нуля, а программа
# должна рассчитать приблизительное значение х, удовлетворяющее этому отклонению. Известно, что глубина точно
# больше нуля и меньше четырёх метров. Обеспечьте контроль ввода.
import math

def func(x):
    return x ** 3 - 3* x ** 2 - 12 * x + 10

def calculate_save_depth(dender_level):
    min_depth = 0
    max_depth = 4
    result = (min_depth + max_depth) / 2

    while math.fabs(func(result)) >= dender_level:
        if math.fabs(func(min_depth)) < math.fabs(func(max_depth)):
            max_depth = result
        else:
            min_depth = result
        result = (min_depth + max_depth) / 2
    return result



def main_function():
    danger_level = float(input('Введите максимально допустимый уровень опасности: '))
    print(f'Приблизительная глубина безопасной кладки: {calculate_save_depth(danger_level)} м')
main_function()


# Задача 8. Сумма ряда
# Что нужно сделать
# Пользователь вводит действительное число х и точность precision. Напишите программу, которая по числу х
# вычисляет сумму ряда в точности до precision.
# Операцией возведения в степень и функцией factorial пользоваться нельзя.

import math

def get_sum_series(x, precision):
    prev_member = n = 0
    current= xn = fn = 1
    while math.fabs(current - prev_member) > precision:
        prev_member = current
        xn *= x * x
        n += 1
        fn *= 2 * n * (2 * n - 1)
        current += (-1 if n % 2 else 1) * xn / fn
    return current

precision = float(input('Введите точность: '))
x = int(input('Введите x: '))
print(f'Сумма ряда = {get_sum_series(x, precision)}')


# Задача 9. Аннуитетный платёж
# Что нужно сделать
# Кредит в сумме S млн руб., выданный на n лет под i% годовых, подлежит погашению равными ежегодными выплатами в
# конце каждого года, включающими процентные платежи и сумму в погашение основного долга. Проценты начисляются
# один раз в год. После выплаты третьего платежа достигнута договорённость между кредитором и заёмщиком о
# продлении срока погашения займа на n_2 лет и увеличении процентной ставки с момента конверсии до i_2%.
# Напишите программу, которая выводит план погашения оставшейся части долга.

def calc_credit(summa, percent, period):
    k = percent * (percent + 1) ** period / ((percent + 1) ** period - 1)
    return  round(summa * k, 2)

summa_credit = float(input('Введите сумму кредита: '))
period = int(input('На сколько лет выдан? '))
percent = float(input('Сколько процентов годовых?'))
print(calc_credit(summa_credit, percent, period))
