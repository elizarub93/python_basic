# Задача 1. Challenge — 2
# Что нужно сделать
# Вдохновившись мотивацией Антона, ваш друг тоже решил поставить перед собой задачу, но не сильно связанную с
# математикой, а именно: написать функцию, которая выводит все числа от 1 до num без использования циклов.
# Помогите другу реализовать такую функцию.

def print_num(num):
    if num > 0:
        print_num(num - 1)
        print(num)


print_num(10)

# Задача 2. Свой zip — 2
# Что нужно сделать
# Написав аналог функции zip на собеседовании, вы вспомнили, что этот код можно сделать даже лучше, и резко вырвали
# листок с кодом из рук работодателя, оставив его в недоумении.
#
# Напишите функцию, которая будет являться аналогом функции zip и сделайте так, чтобы программа работала с любыми
# итерируемыми типами данных.
#
# Нельзя пользоваться циклами (за исключением генераторов), условными операторами и функциями определения
# типа (isinstance или type).
# Функция должна возвращать список с кортежами, в котором n-й кортеж состоит из n-х элементов всех последовательностей.
# Например, десятый кортеж будет содержать десятый элемент каждой из переданных последовательностей.
# Основной код оставьте пустым или закомментированным (используйте его только для тестирования).

def my_zip(*args):
    min_len = min(len(object) for object in args)
    tpl_list = [tuple(obj[i] for obj in args) for i in range(min_len)]
    return tpl_list

# print(my_zip('abc', [1, 2, 3], (4, 5, 6)))


# Задача 3. Ряд Фибоначчи
# Что нужно сделать
# Числа Фибоначчи — это ряд чисел, в котором каждое следующее число равно сумме двух предыдущих: 1, 1, 2, 3, 5, 8, 13…
#
# Пользователь вводит num_pos. Напишите функцию, которая выводит число, стоящее на позиции num_pos в ряде Фибоначчи.

def febonachi(num_pos):
    if num_pos == 1:
        return 1
    if num_pos == 0:
        return 0
    return febonachi(num_pos - 1) + febonachi(num_pos - 2)

num_pos = int(input('Введите позицию числа в ряде Фибоначчи: '))
print('Число:', febonachi(num_pos))

# Задача 4. Поиск элемента — 2
# Что нужно сделать
# Пользователь вводит искомый ключ. Если он хочет, то может ввести максимальную глубину — уровень, до которого
# будет просматриваться структура.
#
# Напишите функцию, которая находит заданный пользователем ключ в словаре и выдаёт значение этого ключа на экран.
# По умолчанию уровень не задан. В качестве примера можно использовать такой словарь:

site = {
    'html': {
        'head': {
            'title': 'Мой сайт'
        },
        'body': {
            'h2': 'Здесь будет мой заголовок',
            'div': 'Тут, наверное, какой-то блок',
            'p': 'А вот здесь новый абзац'
        }
    }
}

def find_value(structure, key, depth=None):
    if depth == 0:
        return None
    if key in structure:
        return structure[key]

    for sub_struct in structure.values():
        if isinstance(sub_struct, dict):
            if depth:
                depth -= 1
            result = find_value(sub_struct, key, depth)
            if result:
                break
    else:
        result = None
    return result

my_key = input('Введите искомый ключ: ')
isDepth = input('Хотите ввести максимальную глубину? Y/N: ')
depth = None
if isDepth.lower() == 'y':
    depth = int(input('Введите максимальную глубину: '))

print('Значение ключа: ', find_value(site, my_key, depth))

# Задача 5. Ускоряем работу функции
# Что нужно сделать
# У нас есть функция, которая делает определённые действия с входными данными:
#
# берёт факториал от числа;
# результат делит на куб входного числа;
# получившееся число возводит в 10-ю степень.
# def calculating_math_func(data):
#     result = 1
#     for index in range(1, data + 1):
#         result *= index
#     result /= data ** 3
#     result = result ** 10
#     return result
# Однако каждый раз нам приходится делать сложные вычисления, хотя входные и выходные данные одни и те же.
# И тут наши знания тонкостей Python должны нам помочь.
#
# Оптимизируйте функцию так, чтобы высчитывать факториал для одного и того же числа только один раз.
#
# Подсказка: вспомните, что происходит с изменяемыми данными, если их выставить по умолчанию в параметрах функции.

def calculating_math_func(data, factorial_list=None):
    if not factorial_list:
        factorial_list = dict()
    result = 1
    if data in factorial_list:
        result = factorial_list[data]
    else:
        for index in range(1, data + 1):
            result *= index
            factorial_list[index] = result
    result /= data ** 3
    result = result ** 10
    return result

print(calculating_math_func(2))
print(calculating_math_func(10))

# Задача 6. Глубокое копирование
# Что нужно сделать
# Вы сделали для заказчика структуру сайта по продаже телефонов:

site = {
    'html': {
        'head': {
            'title': 'Куплю/продам телефон недорого'
        },
        'body': {
            'h2': 'У нас самая низкая цена на iPhone',
            'div': 'Купить',
            'p': 'Продать'
        }
    }
}
# Задача 6. Глубокое копирование
# Заказчик рассказал своим коллегам на рынке, и они тоже захотели такой сайт, только для своих товаров. Вы посчитали,
# что это лёгкая задача, и быстро принялись за работу.
#
# Напишите программу, которая запрашивает у клиента, сколько будет сайтов, а затем запрашивает название продукта и
# после каждого запроса выводит на экран активные сайты.
#
# Условия: структуру сайта нужно описать один раз, копипасту никто не любит.
# Подсказка: используйте рекурсию.

import copy

site = {
    'html': {
        'head': {
            'title': 'Куплю/продам телефон недорого'
        },
        'body': {
            'h2': 'У нас самая низкая цена на iPhone',
            'div': 'Купить',
            'p': 'Продать'
        }
    }
}

def find_value(structure, key, meaning):
    if key in structure:
        structure[key] = meaning
        return structure

    for sub_struct in structure.values():
        if isinstance(sub_struct, dict):
            result = find_value(sub_struct, key, meaning)
            if result:
                return structure

def print_sites(sites_dict):
    for name, info in sites_dict.items():
        print(f'Сайт для {name}: ')
        print(f'site = {info}')

def copy_site(site, count_site):
    sites_dict = dict()
    for _ in range(count_site):
        product_name = input('Введите название продукта для нового сайта: ')
        new_site = copy.deepcopy(site)
        find_value(new_site, 'title', f'Куплю/продам {product_name} недорого')
        find_value(new_site, 'h2', f'У нас самая низкая цена на {product_name}')
        sites_dict[product_name] = new_site
        print_sites(sites_dict)
    return sites_dict


count_sites = int(input('Сколько сайтов: '))
copy_site(site, count_sites)


# Задача 7. Продвинутая функция sum
# Что нужно сделать
# Как вы знаете, в Python есть полезная функция sum, которая умеет находить сумму элементов списков. Но иногда
# базовых возможностей функций не хватает для работы и приходится их усовершенствовать.
#
# Напишите свою функцию sum, которая должна быть более гибкой, чем стандартная функция sum. Она должна уметь:
#
# складывать числа из списка списков;
# складывать числа из набора параметров.
# Основной код оставьте пустым или закомментированным (используйте его только для тестирования).
#
# Примеры вызовов функции:
# sum([[1, 2, [3]], [1], 3])
# Ответ в консоли: 10
#
# sum(1, 2, 3, 4, 5)
# Ответ в консоли: 15

def my_sum(*arg):
    sum_elem = 0
    if isinstance(arg[0], list):
        for elem in arg[0]:
            if isinstance(elem, list):
                elem = my_sum(elem)
            sum_elem += elem
    else:
        for num in arg:
            sum_elem += num

    return sum_elem


print(my_sum(1, 2, 3, 4, 5))

# Задача 8. Список списков — 2
# Что нужно сделать
# Вы уже работали с многомерными списками и решали задачи, где с помощью list comprehensions «выпрямляли» многомерные
# списки в один. Однако такой фокус не пройдёт, если у элементов разные уровни вложенности и этих списков неограниченное
# количество.
#
# Дан такой список:
#
# nice_list = [1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]], [[11, 12, 13], [14, 15], [16, 17, 18]]]
#
# Напишите рекурсивную функцию, которая раскрывает все вложенные списки, то есть оставляет только внешний список.
#
# Ответ: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]

# Подсказка: можно возвращать списки и срезы списков.

def straight_list(obj):
    if not obj:
        return obj

    if isinstance(obj[0], list):
        return straight_list(obj[0]) + straight_list(obj[1:])
    return obj[:1] + straight_list(obj[1:])


nice_list = [1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]], [[11, 12, 13], [14, 15], [16, 17, 18]]]
print(straight_list(nice_list))

# Задача 9. Ханойские башни
# Что нужно сделать
# Ниже представлен текст одной из классических головоломок и по совместительству алгоритмических задач по
# программированию. С ней знакомы многие, в том числе те, кто с программированием никак не связан.
#
# Головоломка «Ханойские башни» состоит из трёх стержней, пронумерованных числами 1, 2, 3. На стержень 1
# надета пирамидка из N дисков различного диаметра в порядке возрастания диаметра. Диски можно перекладывать
# с одного стержня на другой по одному, при этом диск нельзя класть на диск меньшего диаметра.
#
# Необходимо переложить всю пирамидку со стержня 1 на стержень 3 за минимальное число перекладываний.

def hanoe_tower(disc, start=1, end=3):
    if disc == 1:
        print(f'Переложить диск {disc} со стержня номер {start} на стержень номер {end}')
    else:
        hanoe_tower(disc - 1, start, 6 - start - end)
        print(f'Переложить диск {disc} со стержня номер {start} на стержень номер {end}')
        hanoe_tower(disc - 1, 6 - start - end, end)

count_disc = int(input('Введите количество дисков:'))
hanoe_tower(count_disc)



